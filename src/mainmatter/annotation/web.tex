\chapter{Reliable Web Applications}%
\label{cha:reliable_web_applications}

\begin{itemize}
	\item What is the Web?
	\begin{itemize}
		\item What is a Web application?
		\item Rich Internet Application (RIA)?
	\end{itemize}
	\item JavaScript or ECMAScript
	\begin{itemize}
		\item Creation of JavaScript
		\item Browser performance war with Just In Time compilation (JIT)
		\item Explosion of JavaScript and Node
		\item JavaScript issues
		\item The ``transpilation to JavaScript'' paradigm
	\end{itemize}
	\item Frontend Web programming
	\begin{itemize}
		\item Single Page Application (SPA)?
		\item Reactive programming
		\item Functional Reactive programming (FRP)
		\item About the Virtual DOM
		\item Async and the event loop
	\end{itemize}
	\item Elm
	\begin{itemize}
		\item Pure functions
		\item Algebraic Data Types (making impossible states impossible)
		\item Totality
		\item Switch to The Elm Architecture (TEA)
		\item 0 runtime exception
		\item Elm-UI, an alternative layout approach
	\end{itemize}
\end{itemize}


\section{What is the Web?}%
\label{sec:web}

The Internet and the Web are ubiquitous technologies of our everyday lives,
created around the 80's.
Social media, communication, search, news, entertainment, mapping,
shopping, learning, allmost every activity is now digital and online.
Simply put, the Web, also called World Wide Web (WWW), consists of the sum of all resources,
available through unique identifiers (URI), that we share on the Internet,
the global network carrying them.

In this chapter, we will recap the Web main evolutions,
from static content to dynamic applications,
and explain the choices we made to build reliable annotation Web applications.

\subsection{What is a Web application?}%
\label{sub:web_application}

An application, in the context of programming (/computers),
is a piece of software presenting information to a user,
usually in an actionable manner.
This includes things like email clients, image manipulation, video games,
word processors, automatic translation, and virtually any functionality
available with a regular computing device.

Web resources are commonly accessible through a Web browser.
As of May 2019, the three most used Web browsers are Google Chrome (62.7\% of global market share),
Apple Safari (15.9\%) and Mozilla Firefox (5.1\%).
\alert{Cf http://gs.statcounter.com/browser-market-share/all/worldwide/2019}
Thus, we can define a Web application as a user-facing software,
accessed through a Web browser.

The three pillars of Web applications are HTML, CSS and JavaScript.
HTML, for ``Hypertext Markup Language'' is a description language
orginizing a page information as a hierarchy of tagged content.
In Listing~\ref{lst:html}, a ``body'' tag contains three other tags,
a title ``h1'' (h for header), a paragraph ``p'', an image ``img''
and a button not yet linked to any action.
CSS, for ``Cascading Style Sheet'', complements HTML by styling
the content of associated HTML documents.
Listing~\ref{lst:css} shows how we would add a left margin of 20 pixels
on all the document body, and make the h1 title red and bold.
JavaScript is a scripting language, not affiliated in any form
to the Java programming language.
It is run inside the browser to add dynamic behavior to a Web page.
In Listing~\ref{lst:js} we show how one could count and display
the number of times a user clicked on the button in the page.

\lstset{style=CodeStyle}
\lstinputlisting[language=html,caption={Example HTML code.},label={lst:html}]{assets/code/html.html}
\lstinputlisting[language=css,caption={Example CSS code.},label={lst:css}]{assets/code/css.css}
\lstinputlisting[language=js,caption={Example JavaScript code.},label={lst:js}]{assets/code/js.js}

\subsection{Rich Web Application}%
\label{sub:rich_web_application}

Traditionally, websites used to present their resources in the form of a collection
of static documents, known as Web pages, linked together with hyperlinks.
The nature of web pages would mostly be informative, visual or textual,
with very few other interactions than navigation through the site by
clicking on the links.

Today, thanks to evolutions of Web technologies that we will detail later,
Web applications have become full-fledged applications with almost
the same capabilities as desktop ones.
They feature functionalities like 3D graphics, sound processing or interactive elements,
and are sometimes called rich web applications.
Similar concepts like ``progressive web applications'' (PWA),
or ``single page applications'' (SPA) are also explained in the following sections.
Now let's dive into the cornerstone of Web pages dynamism, JavaScript.


\section{JavaScript, formally known as ECMAScript}%
\label{sec:javascript_formally_known_as_ecmascript}

\subsection{Genesis of JavaScript}%
\label{sub:genesis_of_javascript}

In 1995, the dominating Web browser was the Netscape Navigator.
Realizing that pages dynamism was key in the war against Microsoft
own Web technologies, Netscape Communications recruited Brendan Eich,
with the aim of integrating a scripting language into their browser.
And so, in May 1995, he wrote a prototype in 10 days.
Assumably for marketing reasons, it was officially named JavaScript
when realeased in Netscape Navigator 2.0 beta 3.

Two years later, in June 1997, the European Computer Manufacturers Association
(ECMA) standardized the first version of ``ECMAScript'' as ECMA-262,
JavaScript being its most well known implementation.
The ECMAScript (ES) standard has been evolving since.
Today, all browsers fully implement ES5, released in 2009,
and partially implement the most recent versions, ES2015,
ES2016, ES2017 and ES2018.

\subsection{Browser performance war}%
\label{sub:browser_performance_war}

Though many browser wars for dominance of market share occurred since the 90's,
we are interested in the JavaScript engine performance war, starting around 2008
when Google released its Chrome browser.
On September 2, 2008, Google announced a new Web browser called Chrome.
\alert{Cf https://blog.chromium.org/2008/09/google-chromes-need-for-speed\_02.html}
The main selling point was its new JavaScript engine called V8,
greatly improving the browser performances on web applications making
heavy use of JavaScript like their email client Gmail.
Beware that ``performance'' in a browser is the result of many factors
such that network latency, DOM computation, page rendering or JavaScript processing.
In this section, we will specifically focus JavaScript execution performances.

\subsubsection{Dynamic interpretation}%
\label{ssub:dynamic-interpretation}

Previously, JavaScript was an interpreted language.
For each line of code, the engine would translate it into machine code,
and immediately execute it.
This means that for a loop, the transformation from JavaScript to machine code
is repeated over and over again.
In addition, JavaScript is a dynamic language, which is one of its
strongest points, but also a nightmare for execution.
Let's take the function adding two numbers as an example
as in Listing~\ref{lst:add-js}.

\lstinputlisting[language=js,caption={Add two values.},label={lst:add-js}]{assets/code/add.js}

\begin{displayquote}
According to the ECMAScript specification,
\alert{(cf http://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1)}
the addition operator either performs string concatenation or numeric addition.
The production ``AdditiveExpression : AdditiveExpression + MultiplicativeExpression''
is evaluated as follows:

\begin{enumerate}
    \item Let lref be the result of evaluating AdditiveExpression.
    \item Let lval be GetValue(lref).
    \item Let rref be the result of evaluating MultiplicativeExpression.
    \item Let rval be GetValue(rref).
    \item Let lprim be ToPrimitive(lval).
    \item Let rprim be ToPrimitive(rval).
    \item If Type(lprim) is String or Type(rprim) is String, then
    \begin{enumerate}
        \item     Return the String that is the result of concatenating ToString(lprim) followed by ToString(rprim)
    \end{enumerate}
    \item Return the result of applying the addition operation to ToNumber(lprim) and ToNumber(rprim). See the Note below 11.6.3.
\end{enumerate}

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner.

NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.5), by using the logical-or operation instead of the logical-and operation.
\end{displayquote}

In theory, if we know that we will only use this function
to sum two numbers, it should compile to a single instruction.
However, due to the dynamic nature of JavaScript,
as specified in the standard, the code has to check if the arguments
are strings, objects, and proceed first with conversions before
eventually reaching the instruction doing the addition.
This process results in one or two orders of magnitude slower code,
compared to statically typed languages like C or Java.

\subsubsection{Just-in-time (JIT) compilation}%
\label{ssub:just_in_time_jit_compilation}

Statically typed languages usually compile code ahead-of-time (AOT),
while dynamically typed languages interpret code at runtime.
Starting with Chrome in 2008, all browser vendors began implementing
just-in-time (JIT) compilers.

The key ingredient is a ``monitor'' sometimes called ``profiler''.
The monitor watches the code while it is run by the interpreter,
and keeps track of how often a piece of code is executed.
Once a path of code is repeatedly executed, it becomes ``hot'',
which triggers an optimizing compiler.
According to the types previously used in the hot path,
the optimizing compiler will make assumptions enabling
extremely efficient machine code.
If the same code is used once with different types however,
it gets de-optimized back to the baseline compiler.
Multiple optimization and de-optimization round trips
hinders the performances, and consequently will permanently mark
the section as not to be optimized anymore.
A lot more could be said here,
\alert{CF https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/.}

Figure (\alert{TODO faire un schéma timeline}) outlines the differences between
interpreting and JITing regarding the ratio of time spent on each phase.
Fun fact, in V8 the baseline compiler and interpreter is known as ``Ignition''
and the optimizing compiler goes by the name of ``TurboFan''.

\comment{}{

December 18, 2007 - https://webkit.org/blog/152/announcing-sunspider-09/
December 19, 2007 - https://blog.codinghorror.com/the-great-browser-javascript-showdown/
September 2, 2008 - https://blog.chromium.org/2008/09/google-chromes-need-for-speed_02.html
 -> realease date of Chrome
September 3, 2008 - https://johnresig.com/blog/javascript-performance-rundown/
September 3, 2008 - https://arstechnica.com/information-technology/2008/09/new-firefox-javascript-engine-is-faster-than-chromes-v8/
September 5, 2008 - https://www.zdnet.com/article/is-firefox-faster-than-chrome/
September 19, 2008 - http://www.satine.org/archives/2008/09/19/squirrelfish-extreme-fastest-javascript-engine-yet/
November 14, 2008 - https://allanfeid.com/content/javascript-engine-benchmark-test-results


SunSpider: JS perf test suite by WebKit team
https://www2.webkit.org/perf/sunspider/sunspider.html
no longer maintained -> cf JetStream

JetStream: Test JS and wasm
https://browserbench.org/JetStream/

V8 Benchmark: heavy emphasis on recursion
}



\subsection{Explosion of JavaScript and Node}%
\label{sub:explosion_of_javascript_and_node}

